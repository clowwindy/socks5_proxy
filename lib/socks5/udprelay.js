// Generated by CoffeeScript 1.6.3
(function() {
  var LRUCache, dgram, inet, inetAton, inetNtoa, utils;

  utils = require('./utils');

  inet = require('./inet');

  inetNtoa = function(buf) {
    return buf[0] + "." + buf[1] + "." + buf[2] + "." + buf[3];
  };

  inetAton = function(ipStr) {
    var buf, i, parts;
    parts = ipStr.split(".");
    if (parts.length !== 4) {
      return null;
    } else {
      buf = new Buffer(4);
      i = 0;
      while (i < 4) {
        buf[i] = +parts[i];
        i++;
      }
      return buf;
    }
  };

  dgram = require('dgram');

  LRUCache = (function() {
    function LRUCache(timeout, sweepInterval) {
      var sweepFun, that;
      this.timeout = timeout;
      that = this;
      sweepFun = function() {
        return that.sweep();
      };
      this.interval = setInterval(sweepFun, sweepInterval);
      this.dict = {};
    }

    LRUCache.prototype.setItem = function(key, value) {
      var cur;
      cur = process.hrtime();
      return this.dict[key] = [value, cur];
    };

    LRUCache.prototype.getItem = function(key) {
      var v;
      v = this.dict[key];
      if (v) {
        v[1] = process.hrtime();
        return v[0];
      }
      return null;
    };

    LRUCache.prototype.delItem = function(key) {
      return delete this.dict[key];
    };

    LRUCache.prototype.sweep = function() {
      var dict, diff, k, keys, swept, v, v0, _i, _len;
      utils.debug("sweeping");
      dict = this.dict;
      keys = Object.keys(dict);
      swept = 0;
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        k = keys[_i];
        v = dict[k];
        diff = process.hrtime(v[1]);
        if (diff[0] > this.timeout) {
          swept += 1;
          v0 = v[0];
          v0.close();
          delete dict[k];
        }
      }
      return utils.debug("" + swept + " keys swept");
    };

    return LRUCache;

  })();

  exports.createServer = function(port, timeout) {
    var clientKey, clients, server;
    server = dgram.createSocket("udp4");
    clients = new LRUCache(timeout, 10 * 1000);
    clientKey = function(localAddr, localPort, remoteAddr, remotePort) {
      return "" + localAddr + ":" + localPort + ":" + remoteAddr + ":" + remotePort;
    };
    server.on("message", function(data, rinfo) {
      var addrLen, addrtype, client, frag, headerLength, key, remoteAddr, remotePort;
      console.error("server got: " + data + " from " + rinfo.address + ":" + rinfo.port);
      frag = data[2];
      utils.debug("frag:" + frag);
      if (frag !== 0) {
        utils.wran("drop a message since frag is not 0");
        return;
      }
      addrtype = data[3];
      if (addrtype === 3) {
        addrLen = data[4];
      } else if (addrtype !== 1 && addrtype !== 4) {
        utils.error("unsupported addrtype: " + addrtype);
        connection.destroy();
        return;
      }
      if (addrtype === 1) {
        remoteAddr = inetNtoa(data.slice(4, 8));
        remotePort = data.readUInt16BE(8);
        headerLength = 10;
      } else if (addrtype === 4) {
        remoteAddr = inet.inet_ntop(data.slice(4, 20));
        remotePort = data.readUInt16BE(20);
        headerLength = 22;
      } else {
        remoteAddr = data.slice(5, 5 + addrLen).toString("binary");
        remotePort = data.readUInt16BE(5 + addrLen);
        headerLength = 5 + addrLen + 2;
      }
      utils.debug("UDP send to " + remoteAddr + ":" + remotePort);
      key = clientKey(rinfo.address, rinfo.port, remoteAddr, remotePort);
      client = clients.getItem(key);
      if (client == null) {
        client = dgram.createSocket("udp4");
        clients.setItem(key, client);
        client.on("message", function(data1, rinfo1) {
          var data2, header, ipBuf;
          utils.debug("client got " + data1 + " from " + rinfo1.address + ":" + rinfo1.port);
          ipBuf = inetAton(rinfo1.address);
          header = new Buffer(10);
          header.write('\x00\x00\x00\x01', 0);
          ipBuf.copy(header, 4, 0, 4);
          header.writeUInt16BE(rinfo1.port, 8);
          data2 = Buffer.concat([header, data1]);
          return server.send(data2, 0, data2.length, rinfo.port, rinfo.address, function(err, bytes) {
            return utils.debug("remote to client sent");
          });
        });
        client.on("error", function(err) {
          return utils.debug("error: " + err);
        });
        client.on("close", function() {
          utils.debug("close");
          return clients.delItem(key);
        });
      }
      utils.debug("pairs: " + (Object.keys(clients.dict).length));
      return client.send(data, headerLength, data.length - headerLength, remotePort, remoteAddr, function(err, bytes) {
        return utils.debug("client to remote sent");
      });
    });
    server.on("listening", function() {
      var address;
      address = server.address();
      return console.error("server listening " + address.address + ":" + address.port);
    });
    server.bind(port);
    return server;
  };

}).call(this);
